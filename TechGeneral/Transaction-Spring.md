
# Transaction Concepts in Spring

- Reference:

https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth

## Spring Transaction Management: @Transactional In-Depth

- Topics: 

    - @Transactional (Declarative Transaction Management) vs Programmatic Transaction Management.

    - Physical vs Logical transactions.

    - Spring @Transactional and JPA / Hibernate integration.

    - Spring @Transactional and Spring Boot or Spring MVC integration.

    - Rollbacks, Proxies, Common Pitfalls and much more.

## How plain JDBC Transaction Management works

### How to start, commit or rollback JDBC transactions
```
import java.sql.Connection;

Connection connection = dataSource.getConnection(); // (1)

try (connection) {
    connection.setAutoCommit(false); // (2)
    // execute some SQL statements...
    connection.commit(); // (3)

} catch (SQLException e) {
    connection.rollback(); // (4)
}

```

Yes, these 4 lines are (oversimplified) everything that Spring does whenever you are using the *@Transactional* annotation. In the next chapter you’ll find out how that works. But before we go there, there’s a tiny bit more you need to learn.

### How to use JDBC isolation levels and savepoints

```
@Transactional(propagation=TransactionDefinition.NESTED,
               isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED)
```

This can be translated into plain jdbc codes,

```
import java.sql.Connection;

// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED

connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); // (1)

// propagation=TransactionDefinition.NESTED

Savepoint savePoint = connection.setSavepoint(); // (2)
...
connection.rollback(savePoint);
```

- This is how Spring sets isolation levels on a database connection. Not exactly rocket science, is it?

- Nested transactions in Spring are just JDBC / database savepoints. If you don’t know what a savepoint is, have a look at this tutorial, for example. Note that savepoint support is dependent on your JDBC driver/database.

## How Spring’s or Spring Boot’s Transaction Management works


### How to use Spring’s Programmatic Transaction Management?

```
@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            // execute some SQL that e.g.
            // inserts the user into the db and returns the autogenerated id
            return id;
        });
    }
}
```
Compared with the plain JDBC example:

- You do not have to mess with opening or closing database connections yourself (try-finally). Instead you use Transaction Callbacks.

- You also do not have to catch SQLExceptions, as Spring converts these exceptions to runtime exceptions for you.

- And you have better integration into the Spring ecosystem. TransactionTemplate will use a TransactionManager internally, which will use a data source. All are beans that you have to specify in your Spring context configuration, but then don’t have to worry about anymore later on.

While this counts as a minor improvement, programmatic transaction management is not what Spring’s transaction framework mainly is about. Instead, it’s all about **declarative transaction management**. Let’s find out what that is


### How to use Spring’s XML Declarative Transaction Management?

```

<!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- the transactional semantics... -->
        <tx:attributes>
            <!-- all methods starting with 'get' are read-only -->
            <tx:method name="get*" read-only="true"/>
            <!-- other methods use the default transaction settings (see below) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

-------------------
<aop:config>
    <aop:pointcut id="userServiceOperation" expression="execution(* x.y.service.UserService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="userServiceOperation"/>
</aop:config>

<bean id="userService" class="x.y.service.UserService"/>

-------------------

public class UserService {

    public Long registerUser(User user) {
        // execute some SQL that e.g.
        // inserts the user into the db and retrieves the autogenerated id
        return id;
    }
}
```

So, this leads to the question: Is there a better way for declarative transaction management instead of XML? Yes, there is: **The @Transactional annotation**.

### How to use Spring’s @Transactional annotation ( Declarative Transaction Management )

```
@Configuration
@EnableTransactionManagement <---------------------- here
public class MySpringConfig {

    @Bean
    public PlatformTransactionManager txManager() {
        return yourTxManager; // more on that later
    }

}

public class UserService {

    @Transactional  <---------------------- here
    public Long registerUser(User user) {
       // execute some SQL that e.g.
        // inserts the user into the db and retrieves the autogenerated id
        // userDao.save(user);
        return id;
    }
}

```

- Armed with the knowledge from the JDBC transaction example, the @Transactional UserService code above translates (simplified) directly to this:

```
public class UserService {

    public Long registerUser(User user) {
        Connection connection = dataSource.getConnection(); // (1)
        try (connection) {
            connection.setAutoCommit(false); // (1)

            // execute some SQL that e.g.
            // inserts the user into the db and retrieves the autogenerated id
            // userDao.save(user); <(2)

            connection.commit(); // (1)
        } catch (SQLException e) {
            connection.rollback(); // (1)
        }
    }
}
```

### CGlib & JDK Proxies - @Transactional under the covers


![SpringTransactional-01](https://github.com/oopsmails/general-info/TechGeneral/SpringTransactional-01.png)

- Spring constructs a dynamic CGLib proxy of your UserService class here that can open and close database transactions for you. You or any other beans won’t even notice that it is not your UserService, but a proxy wrapping your UserService.

### For what do you need a Transaction Manager (like PlatformTransactionManager)?


Now there’s only one crucial piece of information missing, even though we have mentioned it a couple of times already.

Your UserService gets proxied on the fly, and the proxy manages transactions for you. But it is not the proxy itself handling all this transactional state (open, commit, close), the proxy delegates that work to a transaction manager.

Spring offers you a PlatformTransactionManager / TransactionManager interface, which, by default, comes with a couple of handy implementations. One of them is the datasource transaction manager.

```
@Bean
public DataSource dataSource() {
    return new MysqlDataSource(); // (1)
}

@Bean
public PlatformTransactionManager txManager() {
    return new DataSourceTransactionManager(dataSource()); // (2)
}
```

Simple as. All transaction managers then have methods like "doBegin" (for starting a transaction) or "doCommit", which look like this - **taken straight from Spring’s source code** and simplified a bit:


```
public class DataSourceTransactionManager implements PlatformTransactionManager {

    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        Connection newCon = obtainDataSource().getConnection();
        // ...
        con.setAutoCommit(false);
        // yes, that's it!
    }

    @Override
    protected void doCommit(DefaultTransactionStatus status) {
        // ...
        Connection connection = status.getTransaction().getConnectionHolder().getConnection();
        try {
            con.commit();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not commit JDBC transaction", ex);
        }
    }
}
```

![SpringTransactional-02](https://github.com/oopsmails/general-info/TechGeneral/SpringTransactional-02.png)

### What is the difference between physical and logical transactions?

- UserService has a transactional invoice() method. Which calls another transactional method, createPdf() on the InvoiceService.

Now in terms of database transactions, this should really just be **one*** database transaction. (Remember: getConnection(). setAutocommit(false). commit().) Spring calls this physical transaction, even though this might sound a bit confusing at first.

From Spring’s side however, there’s two logical transactions happening: First in UserService, the other one in InvoiceService. Spring has to be smart enough to know that both @Transactional methods, should use the same underlying, physical database transaction.

```
@Service
public class UserService {

    @Autowired
    private InvoiceService invoiceService;

    @Transactional
    public void invoice() {
        invoiceService.createPdf();
        // send invoice as email, etc.
    }
}

@Service
public class InvoiceService {

    @Transactional
    public void createPdf() {
        // ...
    }
}
```

- if  @Transactional(propagation = Propagation.REQUIRES_NEW), Which basically means your code will open **two (physical)*** connections/transactions to the database. (Again: getConnection() x2. setAutocommit(false) x2. commit() x2) Spring now has to be smart enough that the two logical transactional pieces (invoice()/createPdf()) now also map to two different, physical database transactions.

### What are @Transactional Propagation Levels used for?

- **Required (default)**: My method needs a transaction, either open one for me or use an existing one → getConnection(). setAutocommit(false). commit().

- Supports: I don’t really care if a transaction is open or not, i can work either way → nothing to do with JDBC

- Mandatory: I’m not going to open up a transaction myself, but I’m going to cry if no one else opened one up → nothing to do with JDBC

- Require_new: I want my completely own transaction → getConnection(). setAutocommit(false). commit().

- Not_Supported: I really don’t like transactions, I will even try and suspend a current, running transaction → nothing to do with JDBC

- Never: I’m going to cry if someone else started up a transaction → nothing to do with JDBC

- Nested: It sounds so complicated, but we are just talking savepoints! → connection.setSavepoint()


### Read-Only Transactions, flag
- Ref:

https://www.baeldung.com/transaction-configuration-with-jpa-and-spring

The readOnly flag usually generates confusion, especially when working with JPA. From the Javadoc:

```
This just serves as a hint for the actual transaction subsystem; it will not necessarily cause failure of write access attempts. A transaction manager which cannot interpret the read-only hint will not throw an exception when asked for a read-only transaction.
```

The fact is that **we can't be sure that an insert or update won't occur when the *readOnly* flag is set.** This behavior is vendor dependent, whereas JPA is vendor agnostic.

It's also important to understand that the readOnly flag is only relevant inside a transaction. If an operation occurs outside of a transactional context, the flag is simply ignored. A simple example of that would call a method annotated with:

`@Transactional( propagation = Propagation.SUPPORTS,readOnly = true )`


### What are @Transactional Isolation Levels used for?

- This is almost a trick question at this point, but what happens when you configure the @Transactional annotation like so?

`@Transactional(isolation = Isolation.REPEATABLE_READ)`

Yes, it does simply lead to this:

`connection.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);`

- Ref: 
https://www.postgresql.org/docs/9.5/transaction-iso.html

- dirty read
A transaction reads data written by a concurrent uncommitted transaction.

- nonrepeatable read
A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).

- phantom read
A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.

- serialization anomaly
The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.

The SQL standard and PostgreSQL-implemented transaction isolation levels are described in Table 13-1.

Table 13-1. Transaction Isolation Levels

| Isolation Level | Dirty Read  | Nonrepeatable Read  | Phantom Read  | Serialization Anomaly |
| :---:   | :-: | :-: | :-: | :-: |
| Read uncommitted | Allowed, but not in PG	 | Possible | Possible | Possible |
| Read committed | Not possible | Possible | Possible | Possible |
| Repeatable read | Not possible | Not possible | Allowed, but not in PG | Possible |
| Serializable | Not possible | Not possible | Not possible | Not possible |


### The most common @Transactional pitfall

There is one pitfall that Spring beginners usually run into. Have a look at the following code:

```
@Service
public class UserService {

    @Transactional
    public void invoice() {
        createPdf();
        // send invoice as email, etc.
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
```

You have a UserService class with a transactional invoice method. Which calls createPDF(), which is also transactional.

**How many physical transactions would you expect to be open, once someone calls invoice()?**

**Nope, the answer is not two, but one. Why?**

Let’s go back to the proxies' section of this guide. Spring creates that transactional UserService proxy for you, but once you are inside the UserService class and call other inner methods, there is no more proxy involved. This means, no new transaction for you.


### How Spring handles rollbacks (and default rollback policies)
The section on Spring rollbacks will be handled in the next revision of this guide.

- Ref:

https://www.baeldung.com/transaction-configuration-with-jpa-and-spring

Next we'll use the declarative approach to rollback a transaction for the listed checked exceptions. The rollback in our example is on SQLException:

```
@Transactional(rollbackFor = { SQLException.class })
public void createCourseDeclarativeWithCheckedException(Course course) throws SQLException {
    courseDao.create(course);
    throw new SQLException("Throwing exception for demoing rollback");
}
```

Let's see a simple use of attribute noRollbackFor in the declarative approach to prevent rollback of the transaction for the listed exception:

```
@Transactional(noRollbackFor = { SQLException.class })
public void createCourseDeclarativeWithNoRollBack(Course course) throws SQLException {
    courseDao.create(course);
    throw new SQLException("Throwing exception for demoing rollback");
}
```

## How Spring and JPA / Hibernate Transaction Management works

Rewriting the UserService from before to Hibernate would look like this:

```
public class UserService {

    @Autowired
    private SessionFactory sessionFactory; // (1)

    public void registerUser(User user) {

        Session session = sessionFactory.openSession(); // (2)

        // lets open up a transaction. remember setAutocommit(false)!
        session.beginTransaction();

        // save == insert our objects
        session.save(user);

        // and commit it
        session.getTransaction().commit();

        // close the session == our jdbc connection
        session.close();
    }
}
```

This is a plain, old Hibernate SessionFactory, the entry-point for all Hibernate queries.

Manually managing sessions (read: database connections) and transactions with Hibernate’s API.

There is one huge problem with the above code, however:

Hibernate would not know about Spring’s @Transactional annotation.

Spring’s @Transactional would not know anything about Hibernate’s transaction.

But we’d actually love for Spring and Hibernate to integrate seamlessly, meaning that they know about each others' transactions.

In plain code:

```
@Service
public class UserService {

    @Autowired
    private SessionFactory sessionFactory; // (1)

    @Transactional
    public void registerUser(User user) {
        sessionFactory.getCurrentSession().save(user); // (2)
    }

}
```

The same *SessionFactory* as before

But no more manual state management. Instead, getCurrentSession() and @Transactional are in sync.

How to get there?

### Using the HibernateTransactionManager

Instead of using a DataSourcePlatformTransactionManager in your Spring configuration, you will be using a **HibernateTransactionManager (if using plain Hibernate) or JpaTransactionManager (if using Hibernate through JPA)**.

The specialized HibernateTransactionManager will make sure to:

Manage transactions through Hibernate, i.e. the SessionFactory.

Be smart enough to allow Spring to use that very same transaction in non-Hibernate, i.e. @Transactional Spring code.

As always, a picture might be simpler to understand (though note, the flow between the proxy and real service is only conceptually right and oversimplified).

![SpringTransactional-04](https://github.com/oopsmails/general-info/TechGeneral/SpringTransactional-04.png)

